Базовый синтаксис SQL запроса

Одна из основных функций SQL — это получение выборок данных из СУБД. Для этого в SQL используется оператор SELECT. Давайте рассмотрим несколько простых запросов с его участием.

Вывод произвольных значений

Для начала важно понимать, что через оператор SELECT можно выводить данные не только из таблиц базы данных, но и произвольные строки, числа, даты и т.д. Например, так можно вывести произвольную строку:

SELECT "Hello world";



Вывод всех данных из таблицы
Для вывода всех полей из определённой таблицы используется символ *. Давайте взглянем на схему базы данных и выведем данные одной из таблиц.

SELECT * FROM FamilyMembers;


Вывод данных из определённых колонок таблицы

Если необходимо вывести информацию только по определённым столбцам таблицы, а не всю сразу, то это можно сделать перечисляя названия столбцов через запятую:

SELECT member_id, member_name FROM FamilyMembers;


Псевдонимы

В случае, если мы хотим вывести какие-то столбцы таблицы, но чтобы в итоговой выборке они были названы иначе, мы можем использовать псевдонимы (их также называют алиасами).

Их синтаксис достаточно простой, мы должны использовать оператор AS. Как в примере ниже:

SELECT member_id, member_name AS Name FROM FamilyMembers;

Или же можно обойтись и без него, просто написав желаемое наименование поля через пробел.


SELECT member_id, member_name Name FROM FamilyMembers;

Псевдонимы могут содержать до 255 знаков (включая пробелы, цифры и специальные символы)

Самостоятельные упражнения
Это наш первый урок практического модуля. До этого были лишь теоретические, направленные на восполнение потенциальных пробелов в теории реляционных баз данных. После каждого практического урока мы предлагаем группу заданий для самостоятельной работы, чтобы сразу же закрепить полученную информацию.




Литералы в SQL
На прошлом уроке выводили строку, а если говорить более формальным языком, то так называемый строковый литерал.

SELECT "Hello world";

Литерал — это указанное явным образом фиксированное значение, например, число 12 или строка "SQL".

Основными типами литералов в MySQL являются:

- строковый
- числовой
- логический
- NULL
- литерал даты и времени


Строковые литералы

Строка — это последовательность символов, заключённых в одинарные "(')" или двойные '(")' кавычки. Например, 'это строка' и "это строка".

Строки могут содержать специальные последовательности символов, начинающиеся с "\" (экранирующий символ). Они нужны для того, чтобы СУБД придала обычным символам (буквам и другим знакам) новое особое значение. Например, последовательность "\n" буквально означает "перевод строки", а без предваряющего слеша это была бы обычная буква "n".

SELECT "Строка Другая строка" as String;

Строка Другая строка




SELECT "Строка \n Другая строка" as String;


Строка
Другая строка


Числовые литералы:

- Включает в себя целые и дробные числа. Разделительный знак для дробного числа — «.» (точка).	Пример --> 1, 2.9, 0.01

- Может иметь только целую, дробную часть или обе сразу. Пример --> .2, 1.1, 10

- Может быть положительным и отрицательным числом (для положительного числа совсем не обязательно указывать знак). Пример --> +1, -10, -2.2

- Могут быть представлены в экспоненциальном виде. Пример --> 1e3 (=1000) 1e-3 (=0.001)



Арифметические операторы

Для числовых литералов в SQL есть все привычные нам арифметические операторы:


Оператор		Описание		Пример

%, MOD		   Деление по модулю		11 % 5 = 1
*			Умножение		10 * 16 = 160
+			Сложение		98 + 2 = 100
-			Вычитание		50 - 51 = -1
/			Деление		1 / 2 = 0.5
DIV		  Целочисленное деление	10 DIV 4 = 2


Используя эти операторы можно построить любое арифметическое выражение, применяя стандартные правила арифметики.

Для примера:

SELECT (5 * 2 - 6) / 2 AS Result;

Result
2


Литералы даты и времени

Значения даты и времени могут быть представлены в формате строки или числа.

Например, если мы хотим указать какую-то дату в запросе, то мы можем это сделать с помощью строки "1970-12-30", "19701230" или же числа 19701230. В обоих случаях эти значения будут интерпретироваться как дата «30 декабря 1970 года».

Ниже приведён пример использования литерала даты:

SELECT * FROM FamilyMembers WHERE birthday > '1970-12-30';

Можете не обращать внимание на то, что конкретно делает данный запрос, мы это рассмотрим попозже. Сейчас нам важен именно синтаксис того, как мы можем указывать дату в запросе.

Кроме самой даты, мы можем также указывать отдельно время или же всё вместе.

					Описание							Формат

Дата			Интерпретируется как дата со временем, равным нулю		YYYY-MM-DD, YYYYMMDD
												Вместо разделителя "-" можно использовать любой знак препинания.
												Например:
												'2020-01-01' = 1 января 2020, 00:00:00


Время			Содержит только время без конкретной даты			hh:mm:ss, hh:mm, hh, ss
												Разделитель тоже можно опустить.
												Например:
												12:11 = 12:11:00


Дата и время		Дата с возможностью задать конкретное время			YYYY-MM-DD hh:mm:ss, YYYYMMDDhhmmss
												Например:
												'20200101183030' = 1 января 2020, 18:30:30



Логические литералы
Логический литерал - значения TRUE и FALSE, означающие истинность и ошибочность какого-либо утверждения. При интерпретации запроса, MySQL преобразует их в числа: TRUE и FALSE становятся 1 и 0 соответственно.

NULL
Значение NULL означает "нет данных", "нет значения". Оно нужно, чтобы отличать визуально пустые значения, такие как строка нулевой длины или "пробел", от того, когда значения вообще нет, даже пустого.


Применение функций
При составлении SQL запросов мы можем использовать встроенные функции. Например, если мы хотим вывести строку в верхнем регистре, то для этого мы можем использовать функцию UPPER.

SELECT UPPER("Hello world") AS upper_string;

upper_string
HELLO WORLD



Что такое встроенная функция?
Встроенная функция – реализованный в СУБД кусок кода, с помощью которого можно выполнять преобразования строковых, числовых и других данных в запросах.

Каждая функция принимает набор аргументов определённого типа, выполняет заложенные в неё операции и обязательно возвращает один из возможных литералов. Стоит отметить, что функции могут принимать как ноль аргументов, так и несколько.

Например, функция NOW() принимает ноль аргументов и возвращает литерал в формате даты, а LENGTH('sql-academy') принимает один строковый аргумент и возвращает числовой литерал «11».


Примеры функций
Функций достаточно много, но основные всегда можно найти с помощью поиска в шапке или же на странице справочника функций.

Вот некоторые из них:

* LOWER
Возвращает строку, в которой все символы записаны в нижнем регистре:
SELECT LOWER('SQL Academy') AS lower_string;
lower_string
sql academy


* YEAR

Возвращает год для указанной даты:

SELECT YEAR("2022-06-16") AS year;

year
2022


* INSTR

Осуществляет поиск подстроки в строке, возвращая позицию её первого символа. При этом отсчёт начинается с единицы, а не нуля, как в большинстве языков программирования.

Функция работает путём посимвольного сравнения исходной строки с искомой. Например, в строке sql-academy подстрока academy появляется, начиная с пятого символа.

SELECT INSTR('sql-academy', 'academy') AS idx;

idx
5


* LENGHT

Возвращает длину указанной строки.

SELECT LENGTH('sql-academy') AS str_length;

str_length
11


Применение функций над значениями полей таблицы
Функции можно применять не только над литералами, но и над значениями, взятыми из таблицы. При этом функция выполняет преобразования для каждой строки отдельно.

Например, давайте вернёмся к нашей базе данных и рассмотрим таблицу FamilyMembers: она содержит имя, статус и дату рождения людей.

Каждое значение этих полей мы можем изменить при выводе. Так нижележащий запрос высчитывает длину полного имени для каждого из членов семьи.

SELECT member_name,
	LENGTH(member_name) AS fullname_length
FROM FamilyMembers;



Операции над результатом функции

Поскольку мы знаем, что каждая функция должна вернуть какой-либо из возможных литералов, то её результат также можно использовать в дальнейших расчётах и преобразованиях.

К примеру, мы хотим получить первые три буквы в строке и преобразовать их в заглавные. Для этого нам будет достаточно скомбинировать две функции: LEFT и UPPER, где результат одной функции будет аргументом для второй.


SELECT UPPER(LEFT('sql-academy', 3)) AS str;

str
SQL



Или хотим вычислить длину фамилии человека, имея строку в формате имя<пробел>фамилия. Одним из возможных способов вычисления длины фамилии может быть применение функций LENGTH и INSTR, используя формулу <длина фамилии> = <длина всей строки> - (<длина имени> + <длина пробела>):

 - Значение <длина всей строки> можно получить с помощью функции LENGTH
 - Для <длина имени> + <длина пробела> нужно вычислить позицию символа, где заканчивается имя, и прибавить единицу, т.к. пробел имеет длину «1». Мы можем сделать это используя лишь  	функцию INSTR, ориентируясь на символ «пробел»


Так как обе функции возвращают числовые литералы, мы можем выполнять арифметические операции над ними. Давайте вычтем одно из другого и получим длину фамилии (lastname_length):

SELECT member_name,
	LENGTH(member_name) AS full_length,
	INSTR(member_name, ' ') AS firstname_with_space_length,
	LENGTH(member_name) - INSTR(member_name, ' ') AS lastname_length
FROM FamilyMembers;


* Strings Functions:

1. LENGTH
Возвращает длину строки:

SELECT LENGTH('sql-academy');

2. SUBSTRING
Возвращает подстроку, начинающуюся с указанной позиции [и имеющую определенную длину]
SUBSTRING(str, pos [,len])

str - Исходная строка
pos - Позиция, с которой будет начинаться подстрока
len - Опциональный. Длина полученной подстроки


SELECT SUBSTRING('sql-academy', 5);
SELECT SUBSTRING('sql-academy', 1, 3);


3. REPLACE
Возвращает строку, в которой все подстроки заменены другой подстрокой

REPLACE(str, from_str, to_str)

str - Исходная строка
from_str - Подстрока, которая будем заменена
to_str - Подстрока, которая заменит

SELECT REPLACE('Dear msr Wilson', 'Wilson', 'Brown');

4. LOCATE
Возвращает позицию первого вхождения подстроки в строку

LOCATE(substr, str [,pos])

substr - Искомая подстрока
str - Строка, в которой ищется подстрока
pos - Опциональный. Позиция начала поиска

Если ни одного вхождения не найдено, возвращается 0.

LOCATE('world', 'Hello world')

5. LOWER
Возвращает строку, в которой все символы записаны в нижнем регистре

SELECT LOWER('Hello world')



6. UPPER
Возвращает строку, в которой все символы записаны в верхнем регистре

SELECT UPPER('Hello world')


7. REVERSE
Возвращает строку, записанную в обратном порядке

SELECT REVERSE('drawer');


8. TRIM
Возвращает строку, у которой удалены все пробелы с левого и правого края

SELECT TRIM('  Hello  ')


9. LPAD
Возвращает строку, дополненную слева другой строкой до указанной длины

str - Исходная строка
len - Длина строки, до которой будет дополняться строка
pad_str - Строка, которой будет дополняться исходная строка

SELECT LPAD('9', 5, '0')

10. RPAD
Возвращает строку, дополненную справа другой строкой до указанной длины

str - Исходная строка
len - Длина строки, до которой будет дополняться строка
pad_str - Строка, которой будет дополняться исходная строка

SELECT RPAD('9', 5, '0');


11. LTRIM
Возвращает строку, у которой удалены все пробелы с левого края

SELECT TRIM('  Hello  ')

12. RTRIM
Возвращает строку, у которой удалены все пробелы с правого края

SELECT RTRIM('  Hello  ');

13. REPEAT
Возвращает строку, полученную из count повторений строки str

SELECT REPEAT('111', 3);

14. CONCAT
Возвращает строку, созданную путем объединения всех аргументов

Если хотя бы один из аргументов равен NULL, возвращается значение NULL.


SELECT CONCAT('sql', '-', 'academy');

SELECT CONCAT('sql', NULL);


15. INSTR
Возвращает позицию первого вхождения подстроки в строку

str - Исходная строка
substr - Искомая подстрока

SELECT INSTR('sql-academy', 'academy');

16. LEFT
Возвращает заданное количество крайних левых символов строки

str - Исходная строка
number_of_characters - Количество символов, которые нужно извлечь

SELECT LEFT('sql-academy', 3);


17. RIGHT
Возвращает заданное количество крайних правых символов строки

str - Исходная строка
number_of_characters - Количество символов, которые нужно извлечь

SELECT RIGHT('sql-academy', 3);


18. CHAR
Возвращает строку, созданную путем объединения последовательности из ASCII-кодов

CHAR(num, [num,] ...)

num - Числовой код ASCII для возврата символа

SELECT CHAR(72, 105);



* Functions of numbers

1. CEILING
Возвращает число, округлённое до большего целого

CEILING(num)

SELECT CEILING(0.2);
SELECT CEILING(-0.2);
SELECT CEILING(3);


2. FLOOR
Возвращает число, округлённое до меньшего целого

FLOOR(num)

SELECT FLOOR(-0.2);
SELECT FLOOR(0.2);
SELECT FLOOR(3);


3. ROUND
Возвращает число, округлённое до указанного количества знаков после запятой.

ROUND(num, [decimals])

num - Исходное дробное число
decimals - Количество знаков после запятой для округления числа

Количество знаков после запятой может быть положительным или отрицательным и, при этом, не больше 30
(или -30, в случае отрицательного значения).Если оно отрицательно, то цифры слева от десятичной точки
числа num становятся равными нулю, а дробная часть обрезается.

SELECT ROUND(22.29);
SELECT ROUND(22.29, 1);
SELECT ROUND(22.29, -1);


4. ABS
Возвращает абсолютное значение числа

ABS(num)

SELECT ABS(-2);


5. MOD
Возвращает остаток от деления

MOD(dividend, divisor)

dividend - Делимое
divisor - Делитель


SELECT MOD(7,3);


6. GREATEST
Возвращает максимальное значение из списка


GREATEST(num [,num])

SELECT GREATEST(1,2,-1);


7. LEAST
Возвращает минимальное значение из списка

LEAST(num [,num])

SELECT LEAST(1,2,-1);


8. RAND
Возвращает случайное значение с плавающей точкой в диапазоне от 0.0 до 1.0

RAND([num])

Можно передать необязательный аргумент, причем для одного и того же значения функция будет возвращать
 одно и тоже значение.

SELECT RAND();


9. POW
Возвращает число в указанной степени

POW(num, power)

num - Число, которое возводится в степень
power - Степень числа

SELECT POW(2, 2);


10. SQRT
Возвращает квадратный корень от числа

SQRT(num)

SELECT SQRT(4);


11. SIGN
Возвращает знак переданного числа: -1 для отрицательных значений, 1 для положительных и 0 для 0

SIGN([num])

SELECT SIGN(-2);
SELECT SIGN(2);
SELECT SIGN(0);


12. EXP
Возвращает e в указанной степени

EXP(1)

SELECT EXP(1);


13. LOG
Возвращает логарифм числа

LOG(base, num)

base - Основание алгоритма
num - Число, от которого берется алгоритм

SELECT LOG(10, 100);


14. PI
Возвращает значение числа π

SELECT PI();



* Functions for Date and Time

1. NOW
Возвращает текущую дату в формате ГГГГ-MM-ДД ЧЧ:ММ:СС


NOW()

SELECT NOW();


2. TIMESTAMPADD
Возвращает значение после прибавления к одной даты/времени другой даты/времени

TIMESTAMPADD(unit, value, datetime)

unit - Прибавляемый интервал времени.
Одно из следующих значений MICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR

value - Число прибавляемых указанных интервалов

datetime - Исходная дата/время


Тип интервала	      Описание
MICROSECOND	        Микросекунды
SECOND	              Секунды
MINUTE	               Минуты
HOUR	                Часы
DAY	                    Дни
WEEK	               Недели
MONTH	               Месяцы
QUARTER               Кварталы
YEAR	                Года


SELECT TIMESTAMPADD(HOUR, 3, "2022-12-05 10:37:22") as date;


3. TIMESTAMPDIFF
Возвращает разницу между двумя DATE или DATETIME в конкретной единице измерения

TIMESTAMPDIFF(unit, datetime1, datetime2)

unit - Единица измерения, в которой нужно вернуть разницу между значениями.

datetime1 - Значение, которое будет вычитаться из datetime2

datetime2 - Значение, из которого будет вычитаться datetime1


Единица измерения	        Описание
MICROSECOND	                Микросекунды
SECOND	                    Секунды
MINUTE	                    Минуты
HOUR	                    Часы
DAY	                        Дни
WEEK	                    Недели
MONTH	                    Месяцы
QUARTER	                    Кварталы
YEAR	                    Года

SELECT TIMESTAMPDIFF(YEAR,'2012-06-12','2022-12-05');
SELECT TIMESTAMPDIFF(DAY,'2022-06-12','2022-12-05');


4. DATE_FORMAT
Форматирует дату и время в соответствии со строкой format

DATE_FORMAT(datetime, format)

datetime - Исходная дата/время
format - Формат для использования

Определитель	    Описание
%a	                Сокращенное наименование дня недели (Sun...Sat)
%b	                Сокращенное наименование месяца (Jan...Dec)
%c	                Месяц в числовой форме (1...12)
%D	                День месяца с английским суффиксом (1st, 2nd, 3rd и т. д.)
%d	                День месяца в числовой форме с ведущим нулем (01..31)
%e	                День месяца в числовой форме (1..31)
%f	                Микросекунды (000000..999999)
%H	                Час с ведущим нулем (00..23)
%h	                Час с ведущим нулем (01..12)
%I	                Час с ведущим нулем (01..12)
%i	                Минуты с ведущим нулем (00..59)
%j	                День года (001..366)
%k	                Час с ведущим нулем (0..23)
%l	                Час без ведущего нуля (1..12)
%M	                Название месяца (January...December)
%m	                Месяц в числовой форме с ведущим нулем (01..12)
%p	                AM или PM (для 12-часового формата)
%r	                Время, 12-часовой формат (hh:mm:ss AM|hh:mm:ss PM)
%S	                Секунды (00..59)
%s	                Секунды (00..59)
%T	                Время, 24-часовой формат (hh:mm:ss)
%U	                Неделя (00..52), где воскресенье считается первым днем недели
%u	                Неделя (00..52), где понедельник считается первым днем недели
%W	                Название дня недели (Sunday...Saturday)
%w	                День недели (0...6), 0 — Воскресенье, 6 — Суббота
%Y	                Год в 4 разряда ГГГГ
%y	                Год в 2 разряда ГГ


SELECT DATE_FORMAT("2022-06-16 16:37:03", "Начало мероприятия назначено на %d %b, %H:%i") as date_format;



5. DATE
Извлекает из значения даты и времени суток в формате ГГГГ-MM-ДД ЧЧ:ММ:СС дату, отсекая часы, минуты и секунды

DATE(datetime)

SELECT DATE("2022-12-05 10:37:22");


6. DATEDIFF
Возвращает разницу в днях между датами. При вычислении разницы используется дата, время не используется.

DATEDIFF(datetime1, datetime2)

SELECT DATEDIFF('2022-12-05','2022-12-01')


7. TIMEDIFF
Возвращает разницу во времени (datetime1 - datetime2) между DATETIME или TIME значениями.
Результат возвращается в формате ЧЧ:ММ:СС.

TIMEDIFF(datetime1, datetime2)

Возвращает NULL, если одно из переданных значений равно NULL или оба значения имеют разный тип.


SELECT TIMEDIFF('2022-12-05 18:00:00','2022-12-05 14:00:00');
SELECT TIMEDIFF('2022-12-05 18:00:00','2021-12-01 14:00:00');
SELECT TIMEDIFF('2022-12-05 14:00:00','2022-12-05 18:00:00');
SELECT TIMEDIFF('18:00:00','14:00:00');
SELECT TIMEDIFF('18:00:00','2022-12-05 14:00:00');



8. ADDDATE
Возвращает дату, к которой прибавлен временной интервал, определяемый вторым параметром

ADDDATE(datetime, INTERVAL value unit)

datetime - Исходная дата
value - Количество прибавляемого интервала времени
unit - Прибавляемый интервал времени.
Одно из следующих значений MICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR

Тип	                                    Описание	                    Формат
MICROSECOND	                            Микросекунды	                хxxxxx
SECOND	                                Секунды	                        ss
MINUTE	                                Минуты	                        mm
HOUR	                                Часы	                        hh
DAY	                                    Дни	                            DD
WEEK	                                Недели	                        WW
MONTH	                                Месяцы	                        MM
QUARTER	                                Квартал	                        QQ
YEAR	                                Год	                            YY
SECOND_MICROSECOND	                Секунды и микросекунды	            "ss.xxxxxx"
MINUTE_MICROSECOND	            Минуты, секунды и микросекунды	        "mm:ss.xxxxxx"
MINUTE_SECOND	                    Минуты и секунды	                "mm:ss"
HOUR_MICROSECOND	        Часы, минуты, секунды и микросекунды	    "hh:mm:ss.xxxxxx"
HOUR_SECOND                     	Часы, минуты и секунды	            "hh:mm:ss"
HOUR_MINUTE                         	Часы и минуты	                "hh:mm"
DAY_MICROSECOND     	Дни, часы, минуты, секунды и микросекунды	    "DD hh:mm:ss.xxxxxx"
DAY_SECOND	                    Дни, часы, минуты и секунды	            "DD hh:mm:ss"
DAY_MINUTE	                        Дни, часы и минуты	                "DD hh:mm"
DAY_HOUR	                            Дни и часы	                    "DD hh"
YEAR_MONTH	                            Года и месяцы	                "YY-MM"


SELECT ADDDATE('2022-06-16', INTERVAL 10 DAY);


9. SUBDATE
Возвращает дату, из которой вычитан временной интервал, определяемый вторым параметром

SUBDATE(datetime, INTERVAL value unit)

datetime - Исходная дата
value - Количество вычитаемого интервала времени
unit - Вычитаемый интервал времени.
Одно из следующих значений MICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR


Тип	                                        Описание	                            Формат
MICROSECOND	                                Микросекунды	                        хxxxxx
SECOND	                                    Секунды	                                ss
MINUTE	                                    Минуты	                                mm
HOUR	                                    Часы	                                hh
DAY	                                        Дни	                                    DD
WEEK	                                    Недели	                                WW
MONTH	                                    Месяцы	                                MM
QUARTER	                                    Квартал	                                QQ
YEAR	                                    Год	                                    YY
SECOND_MICROSECOND	                    Секунды и микросекунды	                    "ss.xxxxxx"
MINUTE_MICROSECOND	                Минуты, секунды и микросекунды	                "mm:ss.xxxxxx"
MINUTE_SECOND	                        Минуты и секунды	                        "mm:ss"
HOUR_MICROSECOND	                Часы, минуты, секунды и микросекунды	        "hh:mm:ss.xxxxxx"
HOUR_SECOND	                            Часы, минуты и секунды	                    "hh:mm:ss"
HOUR_MINUTE	                                    Часы и минуты	                    "hh:mm"
DAY_MICROSECOND	                Дни, часы, минуты, секунды и микросекунды	        "DD hh:mm:ss.xxxxxx"
DAY_SECOND	                            Дни, часы, минуты и секунды	                "DD hh:mm:ss"
DAY_MINUTE	                                Дни, часы и минуты	                    "DD hh:mm"
DAY_HOUR	                                  Дни и часы	                        "DD hh"
YEAR_MONTH	                                  Года и месяцы	                        "YY-MM"


SELECT SUBDATE('2022-06-16', INTERVAL 10 DAY);


10. YEAR
Возвращает год для указанной даты

YEAR(datetime)

SELECT YEAR("2022-06-16");


11. MONTH
Возвращает числовое значение месяца года (от 1 до 12) для даты

MONTH(datetime)

SELECT MONTH("2022-06-16");


12. DAY
Возвращает возвращает порядковый номер дня в месяце (от 1 до 31)

DAY(datetime)

SELECT DAY("2022-06-16");


13. HOUR
Возвращает значение часа (от 0 до 23) для времени

HOUR(datetime)

SELECT HOUR('2022-06-16 16:37:03');


14. MINUTE
Возвращает значение минут (от 0 до 59) для времени

MINUTE(datetime)

SELECT MINUTE('2022-06-16 16:37:03');


15. CURDATE
Возвращает текущую дату в формате ГГГГ-MM-ДД 00:00:00

CURDATE()

SELECT CURDATE();


16. CURTIME
Возвращает текущее время суток в формате ЧЧ:ММ:СС

CURTIME()

SELECT CURTIME();


17. MONTHNAME
Возвращает строку с названием месяца для даты

MONTHNAME(datetime)

SELECT MONTHNAME("2022-06-16");

18. DAYNAME
Возвращает день недели в виде полного названия

DAYNAME(datetime)

SELECT DAYNAME("2022-06-16");


19. DAYOFWEEK
Возвращает порядковый номер дня в неделе (от 1 до 7), начиная с воскресенья

DAYOFWEEK(datetime)

SELECT DAYOFWEEK("2022-06-16");



* Advanced Functions

1. WITH
Выражение с WITH определяет временный набор данных, который доступен для ссылки на него в последующих запросах

WITH name_cte [(column_1 [, column_2 ] …)] AS (subquery)

name_cte - Название табличного выражения, по которую оно будет доступно
subquery - Подзапрос, результат которого можно будет использовать в других частях SQL запроса

WITH Aeroflot_trips AS
                (SELECT TRIP.* FROM Company
                    INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot")

            SELECT plane, COUNT(plane) AS amount FROM Aeroflot_trips GROUP BY plane;


2. ISNULL
Возвращает 1 или 0 в зависимости равно ли выражение NULL

ISNULL(value)

SELECT ISNULL(NULL);


3. IF
Возвращает значение, переданное 2-ым или 3-им аргументом, в зависимости от истинности условного выражения

IF(condition, value_if_true, value_if_false)

condition - Условное выражение
value_if_true - Значение, возвращаемое если условное выражение истинно
value_if_false - Значение, возвращаемое если условное выражение ложно

SELECT IF(10 > 20, "TRUE", "FALSE");


4. COALESCE
Возвращает первый элемент списка не равный NULL

COALESCE(val1[, val2, ...., val_n])

SELECT COALESCE(NULL, NULL, 1, 2);


5. IFNULL
Возвращает значение, переданное 1-ым аргументом, если оно не равно NULL.
В противном случае, возвращает значение переданное вторым аргументом.

IFNULL(value, alternative_value)

value - Возвращаемое значение, если оно не равно NULL
alternative_value - Альтернативное значение, если значение в первом аргументе было NULL

IFNULL(NULL, "Alternative value");

6. NULLIF
Возвращает NULL, если значения переданные 1-ым или 2-им аргументом совпадают, иначе возвращает значение,
переданное первым аргументом

NULLIF(value_1, value_2)

NULLIF("SQL Academy", "SQL Academy");



Исключение дубликатов, DISTINCT
В некоторых ситуациях SQL запрос на выборку может возвращать повторяющиеся строки данных.

Например, давайте выведем поле class из таблицы Student_in_class из базы данных, в которой организовано
хранение информации о расписании занятий в школе.

SELECT class FROM Student_in_class;


Поскольку в одном классе возможно нахождение нескольких студентов, то не удивительно,
 что при выводе мы можем наблюдать одинаковые значения. Чтобы при выборке избежать такого дублирования,
  есть оператор DISTINCT.

Синтаксис оператора

SELECT [DISTINCT] поля_таблиц FROM наименование_таблицы;

То есть в нашем случае запрос на получение уникальных классов, в которых есть хотя бы один студент,
будет выглядеть следующим образом:

SELECT DISTINCT class FROM Student_in_class;

DISTINCT для нескольких колонок
При использовании оператора DISTINCT для двух и более колонок будут удаляться записи,
которые имеют одинаковые значения по всем полям.

То есть для такой таблицы

first_name	    last_name

John	        Scott
William	        Dawson
Raul	        Hartman
William	        Hartman
John	        Scott
John	        Hartman


запрос с оператором DISTINCT вернул бы все сочетания имён и фамилий кроме дублирующихся «John Scott».

SELECT DISTINCT first_name, last_name FROM User;

first_name	    last_name
John	        Scott
William	        Dawson
Raul	        Hartman
William	        Hartman
John	        Hartman



Условный оператор WHERE
Ситуация, когда требуется сделать выборку по определённому условию, встречается очень часто.
Для этого в операторе SELECT существует оператор WHERE, после которого следуют условия для ограничения строк.
 Если запись удовлетворяет этому условию, то попадает в результат, иначе отбрасывается.


Общая структура запроса с оператором WHERE

SELECT [DISTINCT] поля_таблиц FROM наименование_таблицы
WHERE условие_на_ограничение_строк
[логический_оператор другое_условие_на_ограничение_строк];


Например, запрос с использованием оператора WHERE может выглядеть следующим образом:

SELECT * FROM Student
WHERE first_name = "Grigorij" AND YEAR(birthday) > 2000;


id	    first_name	    middle_name	    last_name	    birthday	                address
33	    Grigorij	    Gennadevich	    Kapustin	    2001-12-13T00:00:00.000Z	ul. Pervomajskaya, d. 45, kv. 6
65	    Grigorij	    Kirillovich	    Kolobov	        2003-07-17T00:00:00.000Z	ul. CHernova, d. 9, kv. 34


В нем используются:

* два оператора сравнения
    first_name = "Grigorij" и YEAR(birthday) > 2000;
* один логический оператор AND
Как результат, в выборке мы получаем данные студентов, которые имеют имя «Grigorij»
и в тоже время чей год рождения больше 2000.


Операторы сравнения
Операторы сравнения служат для сравнения 2 выражений, результатом которого может являться:

- true (что эквивалентно 1)
- false (что эквивалентно 0)
- NULL

Оператор	        Обозначение	                                    Описание

Равенство	            =	                    Если оба значения равны, то результат будет равен 1, иначе 0

Эквивалентность	       <=>	                    Аналогичен оператору равенства, за исключением того, что результат
                                                будет равен 1 в случае сравнения NULL с NULL и 0, когда идёт
                                                             сравнение любого значения с NULL

Неравенство	        <> или !=	                Если оба значения не равны, то результат будет равен 1, иначе 0

Меньше	                <	                  Если одно значение меньше другого, то результат будет равен 1, иначе 0

Меньше или равно	    <=	                            Если одно значение меньше или равно другому,
                                                            то результат будет равен 1, иначе 0

Больше	                >	                  Если одно значение больше другого, то результат будет равен 1, иначе 0

Больше или равно	    >=	                                    Если одно значение больше или равно другому,
                                                                    то результат будет равен 1, иначе 0


Результатом сравнения любого значения с NULL является NULL. Исключением является оператор эквивалентности.


Логические операторы
Логические операторы необходимы для связывания операторов сравнения.

Оператор	        Описание
NOT	                Меняет значение оператора сравнения на противоположный
OR	                Возвращает общее значение выражения истинно, если хотя бы одно из них истинно
AND	                Возвращает общее значение выражения истинно, если они оба истинны
XOR	                Возвращает общее значение выражения истинно, если один и только один аргумент является истинным


Давайте для примера выведем все полёты, которые были совершены на самолёте «Boeing»,
но, при этом, вылет был не из Лондона:

SELECT * FROM Trip
WHERE plane = 'Boeing' AND NOT town_from = 'London';



Операторы IS NULL, BETWEEN, IN
Мы уже познакомились с синтаксисом оператора WHERE и операторами сравнения,
но помимо них в условных запросах мы можем использовать следующие полезные операторы:

- IS NULL
- BETWEEN
- IN

Давайте рассмотрим их применение.

Оператор IS NULL позволяет узнать равно ли проверяемое значение NULL, т.е. пустое ли значение.

Для примера выведем всех преподавателей, у кого отсутствует отчество:

SELECT * FROM Teacher
WHERE middle_name IS NULL;

id	    first_name	    middle_name	    last_name
10	    YUrij	        <NULL>	        Krylov
11	    Andrej	        <NULL>	        Evseev


Для использования отрицания, то есть, если мы хотим найти все записи, где поле не равно NULL,
мы должны использовать следующий синтаксис:

SELECT * FROM Teacher
WHERE middle_name IS NOT NULL;


BETWEEN
Оператор BETWEEN min AND max позволяет узнать расположено ли проверяемое значение столбца
в интервале между min и max, включая сами значения min и max.
Он идентичен условию:

... WHERE field >= min AND field <= max

Используется данный оператор следующим образом:

SELECT * FROM Payments
WHERE unit_price BETWEEN 100 AND 500;

В качестве результата вернутся все записи из таблицы Payments, где значение поля unit_price будет от 100 до 500.


IN
Оператор IN позволяет узнать входит ли проверяемое значение столбца в список определённых значений.

SELECT * FROM FamilyMembers
WHERE status IN ('father', 'mother');

member_id	    status	    member_name         birthday
1	            father	    Headley Quincey	    1960-05-13T00:00:00.000Z
2	            mother	    Flavia Quincey	    1963-02-16T00:00:00.000Z
6	            father	    Ernest Forrest	    1961-09-11T00:00:00.000Z
7	            mother	    Constance Forrest	1968-09-06T00:00:00.000Z


Оператор LIKE

Оператор LIKE используется при условных запросах,
когда мы хотим узнать соответствует ли строка определённому шаблону.

Например, у нас есть таблица Users, в которой есть поле email:

SELECT name, email FROM Users;

name	            email

Bruce Willis	    barjam@hotmail.com
George Clooney	    tellis@me.com
Kevin Costner	    metzzo@hotmail.com
Samuel L. Jackson	moonlapse@outlook.com
Kurt Russell	    gator@live.com


Допустим, мы хотим найти всех пользователей, чья почта лежит в домене второго уровня «hotmail».
Т.е. нужно отобрать только те записи, что отвечают условию:

- после символа «@» следует «hotmail»
- после «hotmail» следует символ «.» и далее любая последовательность символов

Для таких нетривиальных поисков по строковым полям и нужен оператор LIKE.


Синтаксис

... WHERE поле_таблицы [NOT] LIKE шаблон_строки

Шаблон может включать следующие специальные символы:

Символ	        Описание
  %	            Последовательность любых символов (число символов в последовательности может быть от 0 и более)
  _	            Любой единичный символ


Так наш запрос на поиск пользователей в домене «hotmail» может выглядеть следующим образом:

SELECT name, email FROM Users
WHERE email LIKE '%@hotmail.%';

name	                email
Bruce Willis	        barjam@hotmail.com
Kevin Costner	        metzzo@hotmail.com
Jennifer Lopez	        barjam@hotmail.com
Harrison Ford	        kostas@hotmail.com
Michael Douglas	        timtroyr@hotmail.com
Catherine Zeta-Jones	flakeg@hotmail.com


Примеры

* ... WHERE поле_таблицы LIKE 'text%'

Сопоставляется любым строкам, начинающимся на «text»

* ... WHERE поле_таблицы LIKE '%text'

Сопоставляется любым строкам, заканчивающимся на «text»

* ... WHERE поле_таблицы LIKE '_ext'

Сопоставляется строкам, имеющим длину 4 символа, при этом 3 последних обязательно должны быть «ext».
Например, слова «text» и «next»

* ... WHERE поле_таблицы LIKE 'begin%end'

Сопоставляется строкам, начинающихся на «begin» и заканчивающихся на «end»

В MySQL по умолчанию шаблоны не чувствительны к регистру


ESCAPE-символ

ESCAPE-символ используется для экранирования специальных символов (% и \).
В случае если вам нужно найти строки, вы можете использовать ESCAPE-символ.

Например, вы хотите получить идентификаторы задач, прогресс которых равен 3%:

SELECT job_id FROM Jobs
WHERE progress LIKE '3!%' ESCAPE '!';

Если бы мы не экранировали трафаретный символ, то в выборку попало бы всё, что начинается на 3.

Сортировка, оператор ORDER BY
При выполнении SELECT запроса, строки по умолчанию возвращаются в неопределённом порядке.
Фактический порядок строк в этом случае зависит от плана соединения и сканирования,
а также от порядка расположения данных на диске, поэтому полагаться на него нельзя.
Для упорядочивания записей используется конструкция ORDER BY.


Общая структура запроса с оператором ORDER BY

SELECT поля_таблиц FROM наименование_таблицы
WHERE ...
ORDER BY столбец_1 [ASC | DESC][, столбец_n [ASC | DESC]]


Где ASC и DESC - направление сортировки:

* ASC - сортировка по возрастанию (по умолчанию)
* DESC - сортировка по убыванию


Сортировка по нескольким столбцам
Для сортировки результатов по двум или более столбцам их следует указывать через запятую.

...ORDER BY столбец_1 [ASC | DESC], столбец_2 [ASC | DESC];

Данные будут сортироваться по первому столбцу, но в случае если попадаются несколько записей с совпадающими
значениями в первом столбце, то они сортируются по второму столбцу.
Количество столбцов, по которым можно отсортировать, не ограничено.


Правило сортировки применяется только к тому столбцу, за которым оно следует.
ORDER BY столбец_1, столбец_2 DESC

не то же самое, что

ORDER BY столбец_1 DESC, столбец_2 DESC


Примеры использования

* Выведем названия авиакомпаний в алфавитном порядке из таблицы Company:

Сортировка строковых данных по возрастанию подразумевает сортировку в лексикографическом (алфавитном) порядке.

SELECT name FROM Company ORDER BY name;

name

Aeroflot
air_France
British_AW
Dale_avia
Don_avia


* Выведем информацию о полётах, отсортированную по городу вылета самолёта в порядке возрастания и по
городу прибытия в аэропорт в порядке убывания, из таблицы Trip:

SELECT DISTINCT town_from, town_to FROM Trip
ORDER BY town_from, town_to DESC;

town_from	town_to
London	    Singapore
London	    Paris
Moscow	    Rostov
Paris	    Rostov
Rostov	    Vladivostok
Rostov	    Paris


В данном примере в начале записи сортируются по полю town_from. Затем там, если есть несколько записей
с одинаковым значением в поле town_from, то отрабатывает обратная сортировка по полю town_to.


Группировка, оператор GROUP BY
Давайте выполним запрос:
SELECT id, home_type, has_tv, price FROM Rooms;

id	    home_type	        has_tv	    price
1	    Private room	    1	        149
2	    Entire home/apt	    0	        225
3	    Private room	    1	        150
4	    Entire home/apt	    1	        89
5	    Entire home/apt	    0	        80


Так мы получили информацию по каждому сдаваемому жилому помещению.
А что если мы хотим получить информацию не о каждой записи отдельно, а о группах, которые они образуют?

Например, такими группами могут выступать записи разбитые по типу жилья:

- Shared room (аренда комнаты на несколько человек)
- Private room (аренда целой комнаты)
- Entire home/apt (аренда целой квартиры)

Эти группы включают разные записи в таблице и, соответственно, обладают разными характеристиками,
 которые нам могут быть весьма полезны.

Такой полезной информацией о группах может быть:

- средняя стоимость аренды комнаты или целого жилого помещения
- количество сдаваемых жилых помещений каждого типа

Для ответов на все эти и многие другие вопросы есть оператор GROUP BY.

Общая структура запроса с GROUP BY

SELECT [литералы, агрегатные_функции, поля_группировки]
FROM имя_таблицы
GROUP BY поля_группировки;


Для того, чтобы записи у нас образовали группы по типу жилья мы должны после GROUP BY указать home_type,
т.е. поле, по которому будет происходить группировка.

SELECT home_type FROM Rooms
GROUP BY home_type

home_type
Private room
Entire home/apt
Shared room

Следует иметь в виду, что для GROUP BY все значения NULL трактуются как равные, т.е. при группировке по полю,
содержащему NULL-значения, все такие строки попадут в одну группу


При использовании оператора GROUP BY мы перешли от работы с отдельными записями на работу с образовавшимися группами.
В связи с этим мы не можем просто вывести любое поле из записи (например, has_tv или price),
как мы это могли делать раньше. Так как в каждой группе может быть несколько записей и в каждой из них в этом
поле может быть разное значение.


При использовании GROUP BY мы можем выводить только:

* литералы, т.е. указанное явным образом фиксированные значения.
  Мы можем их выводить, так как это фиксированные значения, которые ни от чего не зависят.
  Например,

  SELECT home_type, "literal" FROM Rooms
  GROUP BY home_type

  home_type	        literal
  Private room	    literal
  Entire home/apt	literal
  Shared room	    literal


* результаты агрегатных функций, т.е. вычисленные значения на основании набора значений.
  Более детальную информацию об агрегатных функциях мы затронем на следующем уроке.
  Но для примера рассмотрим агрегатную функцию AVG.
  Функция AVG принимает в качестве аргумента название поля, по которому мы хотим вычислить среднее значение
  для каждой группы.

  SELECT home_type, AVG(price) as avg_price FROM Rooms
  GROUP BY home_type

  home_type	        avg_price
  Private room	    89.4286
  Entire home/apt	148.6667
  Shared room	    40

  Так выполненный запрос сначала разбивает все записи из таблицы Rooms на 3 группы, опираясь на поле home_type.
  Далее, для каждой группы суммирует все значения, взятые из поля price у каждой записи, входящей в текущую группу,
  и затем полученный результат делится на количество записей в данной группе.


* поля группировки.
  Мы можем их выводить, так как в рамках одной группы поля, по которым осуществлялась группировка, одинаковые.


Группировка по 2 и более полям
Мы уже рассмотрели как записи в таблице группируются по одному полю.
Для дополнительной иллюстрации это выглядит примерно так, когда поле группировки home_type:

groupping_by_1_field.png



При группировке по 2 и более полям принцип остается такой же, только теперь образовавшиеся
группы дополнительно разбиваются на более мелкие группы в зависимости от второго поля группировки.

Пример группировки по home_type и has_tv:

groupping_by_2_field.png



Агрегатные функции
В статье об группировках мы обсудили, что при использовании оператора GROUP BY мы можем использовать
агрегатные функции. Давайте поговорим о них поглубже 🐳.

Агрегатная функция – это функция, которая выполняет вычисление на наборе значений и возвращает одиночное значение.


Общая структура запроса с агрегатной функцией

SELECT [литералы, агрегатные_функции, поля_группировки]
FROM имя_таблицы
GROUP BY поля_группировки;


Например, запрос с использованием агрегатной функции AVG может выглядеть так:

SELECT home_type, AVG(price) as avg_price FROM Rooms
GROUP BY home_type

home_type	        avg_price
Private room	    89.4286
Entire home/apt	    148.6667
Shared room	        40


Описание агрегатных функций


Функция	                Описание

SUM(поле_таблицы)	    Возвращает сумму значений
AVG(поле_таблицы)	    Возвращает среднее значение
COUNT(поле_таблицы)	    Возвращает количество записей
MIN(поле_таблицы)	    Возвращает минимальное значение
MAX(поле_таблицы)	    Возвращает максимальное значение


Агрегатные функции применяются для значений, не равных NULL. Исключением является функция COUNT(*).

* Найдём количество каждого вида жилья и отсортируем полученный список по убыванию:

    SELECT home_type, COUNT(*) as amount FROM Rooms
    GROUP BY home_type
    ORDER BY amount DESC;


    home_type	        amount
    Private room	    28
    Entire home/apt	    21
    Shared room	        1


* Для каждого жилого помещения найдём самую позднюю дату выезда (поле end_date):

    SELECT room_id, MAX(end_date) AS last_end_date FROM Reservations
    GROUP BY room_id

    room_id	    last_end_date
    1	        2019-02-04T12:00:00.000Z
    2	        2020-03-23T09:00:00.000Z
    13	        2020-04-21T10:00:00.000Z
    16	        2019-06-24T10:00:00.000Z
    21	        2020-02-29T10:00:00.000Z
    19	        2020-05-02T10:00:00.000Z



Оператор HAVING
Мы уже рассматривали запрос получения средней стоимости аренды жилых помещений в зависимости от типа жилья:

SELECT home_type, AVG(price) as avg_price FROM Rooms
GROUP BY home_type

home_type	        avg_price
Private room	    89.4286
Entire home/apt	    148.6667
Shared room	        40

Давайте доработаем этот запрос таким образом, чтобы в итоговой выборке отображались только те группы,
чья средняя стоимость больше 50.
Обладая предыдущим опытом, есть большой соблазн попытаться использовать для этих целей оператор WHERE.
Но при попытке выполнить такой запрос СУБД неминуемо выдаст ошибку,
указав что мы некорректно используем синтаксис WHERE avg_price > 50.

SELECT home_type, AVG(price) as avg_price FROM Rooms
GROUP BY home_type
WHERE avg_price > 50

Говоря наперёд, для фильтрации групп мы должны использовать оператор HAVING:

SELECT home_type, AVG(price) as avg_price FROM Rooms
GROUP BY home_type
HAVING avg_price > 50

home_type	        avg_price
Private room	    89.4286
Entire home/apt	    148.6667


Порядок выполнения SQL запроса
Но почему же мы не могли использовать WHERE и зачем нужен отдельный оператор для этой цели?
Все дело в порядке выполнения SQL запроса.


* 1 - Получение всех записей из таблицы
                |
                |
* 2 - Фильтрация записей по опредленным условиям
                |
                |
* 3 - Формирование групп на основе записей после фильтрации
                |
                |
* 4 - Фильтрация групп по определенным условиям
                |
                |
* 5 - Сортировка полученных результатов



Наш первый запрос был неверный, потому что мы пытались использовать поле avg_price у образовавшихся групп ещё до
их образования, так как выполнение оператора WHERE предшествует группировке.

То есть оператор WHERE в момент его исполнения ничего не знает о последующей группировке, он работает только с
записями из таблицы. Так мы, например, с его помощью можем отфильтровать записи таблицы Rooms по цене до применения
 группировки и лишь затем вычислить среднюю стоимость групп оставшегося жилья:

SELECT home_type, AVG(price) as avg_price FROM Rooms
WHERE price > 50
GROUP BY home_type

home_type	        avg_price
Private room	    96.875
Entire home/apt	    148.6667


Общая структура запроса с оператором HAVING

SELECT [константы, агрегатные_функции, поля_группировки]
FROM имя_таблицы
WHERE условия_на_ограничения_строк
GROUP BY поля_группировки
HAVING условие_на_ограничение_строк_после_группировки
ORDER BY условие_сортировки


Пример использования HAVING
Для примера давайте получим минимальную стоимость каждого типа жилья c телевизором.
При этом нас интересуют только типы жилья, содержащие как минимум 5 жилых помещений, относящихся к ним.

Чтобы получить такой результат мы должны:

* Сначала получить все данные из таблицы
    SELECT ... FROM Rooms;

* Затем выбрать из всех записей таблиц Room только интересующие нас, т.е. только жильё с телевизором
    SELECT ... FROM Rooms
    WHERE has_tv = True

* Затем сгруппировать данные записи о жилых помещений по их типу
    SELECT ... FROM Rooms
    WHERE has_tv = True
    GROUP BY home_type

* После этого отфильтровать полученных группы по условию, что нас интересуют групп, имеющие как минимум 5 представителей
    SELECT ... FROM Rooms
    WHERE has_tv = True
    GROUP BY home_type
    HAVING COUNT(*) >= 5

* И под конец, посмотреть что нас просят в задании и, соответственно, добавить вывод необходимой информации.
В нашем случае, нам необходимо вывести название типа жилья и его минимальную стоимость.
    SELECT home_type, MIN(price) as min_price FROM Rooms
    WHERE has_tv = True
    GROUP BY home_type
    HAVING COUNT(*) >= 5;
